w = c(w, fun.w(DIHIE4, llIE4N, minll, optIE4_NI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[3]>0){
DIHH4h=det(-pracma::pinv(optH4_NI$hessian))
DIHH4=ifelse(DIHH4h<0,0,DIHH4h)
w = c(w, fun.w(DIHH4, llH4N, minll, optH4_NI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[4]>0){
DIHLN4h=det(-pracma::pinv(optLN4_NI$hessian))
DIHLN4=ifelse(DIHLN4h<0,0,DIHLN4h)
w = c(w, fun.w(DIHLN4, llLN4N, minll, optLN4_NI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[5]>0){
DIHG4h=det(-pracma::pinv(optG4_NI$hessian))
DIHG4=ifelse(DIHG4h<0,0,DIHG4h)
w = c(w, fun.w(DIHG4, llG4N, minll, optG4_NI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[6]>0){
DIHQE4h=det(-pracma::pinv(optQE4_NI$hessian))
DIHQE4=ifelse(DIHQE4h<0,0,DIHQE4h)
# w = c(w, fun.w(DIHQE4, llQE4N, minll, optQE4_NI, data$priormu, data$priorSigma,
#                data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c))
w = c(w, fun.w(DIHQE4, llQE4N, minll, optQE4_NI, data$priormuQ, data$priorSigmaQ,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncdQ))
}else{w=c(w,0)}
if(prior.weights[7]>0){
DIHP4h=det(-pracma::pinv(optP4_NI$hessian))
DIHP4=ifelse(DIHP4h<0,0,DIHP4h)
w = c(w, fun.w(DIHP4, llP4N, minll, optP4_NI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[8]>0){
DIHL4h=det(-pracma::pinv(optL4_NI$hessian))
DIHL4=ifelse(DIHL4h<0,0,DIHL4h)
w = c(w, fun.w(DIHL4, llL4N, minll, optL4_NI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
# lognormal
data=data.LN$data
start=data.LN$start
start=data.LN$startQ
if(prior.weights[9]>0){
DIHE4h=det(-pracma::pinv(optE4_LNI$hessian))
DIHE4=ifelse(DIHE4h<0,0,DIHE4h)
w = c(w, fun.w(DIHE4, llE4LN, minll, optE4_LNI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[10]>0){
DIHIE4h=det(-pracma::pinv(optIE4_LNI$hessian))
DIHIE4=ifelse(DIHIE4h<0,0,DIHIE4h)
w = c(w, fun.w(DIHIE4, llIE4LN, minll, optIE4_LNI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[11]>0){
DIHH4h=det(-pracma::pinv(optH4_LNI$hessian))
DIHH4=ifelse(DIHH4h<0,0,DIHH4h)
w = c(w, fun.w(DIHH4, llH4LN, minll, optH4_LNI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[12]>0){
DIHLN4h=det(-pracma::pinv(optLN4_LNI$hessian))
DIHLN4=ifelse(DIHLN4h<0,0,DIHLN4h)
w = c(w, fun.w(DIHLN4, llLN4LN, minll, optLN4_LNI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[13]>0){
DIHG4h=det(-pracma::pinv(optG4_LNI$hessian))
DIHG4=ifelse(DIHG4h<0,0,DIHG4h)
w = c(w, fun.w(DIHG4, llG4LN, minll, optG4_LNI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[14]>0){
DIHQE4h=det(-pracma::pinv(optQE4_LNI$hessian))
DIHQE4=ifelse(DIHQE4h<0,0,DIHQE4h)
# w = c(w, fun.w(DIHQE4, llQE4LN, minll, optQE4_LNI, data$priormu, data$priorSigma,
#                data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c))
w = c(w, fun.w(DIHQE4, llQE4LN, minll, optQE4_LNI, data$priormuQ, data$priorSigmaQ,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncdQ))
}else{w=c(w,0)}
if(prior.weights[15]>0){
DIHP4h=det(-pracma::pinv(optP4_LNI$hessian))
DIHP4=ifelse(DIHP4h<0,0,DIHP4h)
w = c(w, fun.w(DIHP4, llP4LN, minll, optP4_LNI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
if(prior.weights[16]>0){
DIHL4h=det(-pracma::pinv(optL4_LNI$hessian))
DIHL4=ifelse(DIHL4h<0,0,DIHL4h)
w = c(w, fun.w(DIHL4, llL4LN, minll, optL4_LNI, data$priormu, data$priorSigma,
data$priorlb, data$priorub, data$shape.a, data$shape.BMD, data$shape.c,
data$truncd))
}else{w=c(w,0)}
}
w <- ifelse(w == 'Inf' | is.na(w), 0, w)
lpwlp=(prior.weights*w)/sum(prior.weights*w)
names(lpwlp) = c("E4_N","IE4_N","H4_N","LN4_N","G4_N","QE4_N","P4_N","L4_N","E4_LN","IE4_LN","H4_LN","LN4_LN","G4_LN","QE4_LN","P4_LN","L4_LN")
# the model average posterior as a mixture
count=round(lpwlp*ndraws)
mabmd=(c(# normal
if(prior.weights[1]>0) sample(as.matrix(fitstanE4_N)[,2],count[1],replace=T),
if(prior.weights[2]>0) sample(as.matrix(fitstanIE4_N)[,2],count[2],replace=T),
if(prior.weights[3]>0) sample(as.matrix(fitstanH4_N)[,2],count[3],replace=T),
if(prior.weights[4]>0) sample(as.matrix(fitstanLN4_N)[,2],count[4],replace=T),
if(prior.weights[5]>0) sample(as.matrix(fitstanG4_N)[,2],count[5],replace=T),
if(prior.weights[6]>0) sample(as.matrix(fitstanQE4_N)[,2],count[6],replace=T),
if(prior.weights[7]>0) sample(as.matrix(fitstanP4_N)[,2],count[7],replace=T),
if(prior.weights[8]>0) sample(as.matrix(fitstanL4_N)[,2],count[8],replace=T),
# lognormal
if(prior.weights[9]>0)  sample(as.matrix(fitstanE4_LN)[,2],count[9],replace=T),
if(prior.weights[10]>0) sample(as.matrix(fitstanIE4_LN)[,2],count[10],replace=T),
if(prior.weights[11]>0) sample(as.matrix(fitstanH4_LN)[,2],count[11],replace=T),
if(prior.weights[12]>0) sample(as.matrix(fitstanLN4_LN)[,2],count[12],replace=T),
if(prior.weights[13]>0) sample(as.matrix(fitstanG4_LN)[,2],count[13],replace=T),
if(prior.weights[14]>0) sample(as.matrix(fitstanQE4_LN)[,2],count[14],replace=T),
if(prior.weights[15]>0) sample(as.matrix(fitstanP4_LN)[,2],count[15],replace=T),
if(prior.weights[16]>0) sample(as.matrix(fitstanL4_LN)[,2],count[16],replace=T)
))
macilp=(quantile(mabmd,pvec))*data$maxD
names(macilp)=c("BMDL","BMD","BMDU") # on original scale
if(TRUE %in% (mabmd > data$maxD) && data$maxD > 1){
mabmd = ifelse(mabmd > data$maxD, data$maxD, mabmd)
p.msg = 'The model averaged posterior distribution has been truncated at max(Dose)^2'
warnings('The model averaged posterior distribution has been truncated at max(Dose)^2')
}else{
p.msg = ''
}
BMDq_ls = (quantile(mabmd, seq(0,1,0.005)))*data$maxD
### Model-averaged response per dose level
dr.MA.ls <- c()
for(i in 1:length(data$x)){
dr.MA.ls[i] = weighted.mean(x = c(DRM_E4_N[i],DRM_IE4_N[i],DRM_H4_N[i],DRM_LN4_N[i],DRM_G4_N[i],DRM_QE4_N[i], DRM_P4_N[i],
DRM_L4_N[i] ,
DRM_E4_LN[i], DRM_IE4_LN[i], DRM_H4_LN[i], DRM_LN4_LN[i], DRM_G4_LN[i],DRM_QE4_LN[i],
DRM_P4_LN[i],DRM_L4_LN[i]),
w = lpwlp,
na.rm = T)
}
##### Weights & MA if one of the models is divergent --> this model gets weight 0
if((0 %in% converged) && (1 %in% converged)){
prior.weights.new = prior.weights
div.models = which(converged == 0)
prior.weights.new[div.models] = 0
p.weights.new = prior.weights.new/sum(prior.weights.new==1)
lpwlp.conv=(p.weights.new*w)/sum(p.weights.new*w)
# lpwlp = lpwlp*prior.weights
# the model average posterior as a mixture
count=round(lpwlp.conv*ndraws)
mabmd.conv=(c(# normal
if(p.weights.new[1]>0) sample(as.matrix(fitstanE4_N)[,2],count[1],replace=T),
if(p.weights.new[2]>0) sample(as.matrix(fitstanIE4_N)[,2],count[2],replace=T),
if(p.weights.new[3]>0) sample(as.matrix(fitstanH4_N)[,2],count[3],replace=T),
if(p.weights.new[4]>0) sample(as.matrix(fitstanLN4_N)[,2],count[4],replace=T),
if(p.weights.new[5]>0) sample(as.matrix(fitstanG4_N)[,2],count[5],replace=T),
if(p.weights.new[6]>0) sample(as.matrix(fitstanQE4_N)[,2],count[6],replace=T),
if(p.weights.new[7]>0) sample(as.matrix(fitstanP4_N)[,2],count[7],replace=T),
if(p.weights.new[8]>0) sample(as.matrix(fitstanL4_N)[,2],count[8],replace=T),
# lognormal
if(p.weights.new[9]>0)  sample(as.matrix(fitstanE4_LN)[,2],count[9],replace=T),
if(p.weights.new[10]>0) sample(as.matrix(fitstanIE4_LN)[,2],count[10],replace=T),
if(p.weights.new[11]>0) sample(as.matrix(fitstanH4_LN)[,2],count[11],replace=T),
if(p.weights.new[12]>0) sample(as.matrix(fitstanLN4_LN)[,2],count[12],replace=T),
if(p.weights.new[13]>0) sample(as.matrix(fitstanG4_LN)[,2],count[13],replace=T),
if(p.weights.new[14]>0) sample(as.matrix(fitstanQE4_LN)[,2],count[14],replace=T),
if(p.weights.new[15]>0) sample(as.matrix(fitstanP4_LN)[,2],count[15],replace=T),
if(p.weights.new[16]>0) sample(as.matrix(fitstanL4_LN)[,2],count[16],replace=T)
))
macilp.conv=(quantile(mabmd.conv,pvec))*data$maxD
names(macilp.conv)=c("BMDL","BMD","BMDU")
if(TRUE %in% (mabmd.conv > data$maxD) && data$maxD > 1){
mabmd.conv = ifelse(mabmd.conv > data$maxD, data$maxD, mabmd.conv)
p.msg = 'The model averaged posterior distribution has been truncated at max(Dose)^2'
warnings('The model averaged posterior distribution has been truncated at max(Dose)^2')
}else{
p.msg = ''
}
BMDq_ls_conv = (quantile(mabmd.conv, seq(0,1,0.005)))*data$maxD
### Model-averaged response per dose level
dr.MA.ls.conv <- c()
for(i in 1:length(data$x)){
dr.MA.ls.conv[i] = weighted.mean(x = c(DRM_E4_N[i],DRM_IE4_N[i],DRM_H4_N[i],DRM_LN4_N[i],DRM_G4_N[i],DRM_QE4_N[i],
DRM_P4_N[i], DRM_L4_N[i] ,
DRM_E4_LN[i], DRM_IE4_LN[i], DRM_H4_LN[i], DRM_LN4_LN[i], DRM_G4_LN[i],DRM_QE4_LN[i],
DRM_P4_LN[i],DRM_L4_LN[i]),
w = lpwlp.conv,
na.rm = T)
}
}else if(!(1 %in% converged)){
lpwlp.conv = NULL; macilp.conv = NULL; BMDq_ls_conv = NULL; dr.MA.ls.conv = NULL; mabmd.conv = NA;
}else if(!(0 %in% converged)){
lpwlp.conv = lpwlp; macilp.conv = macilp; BMDq_ls_conv = BMDq_ls; dr.MA.ls.conv = dr.MA.ls; mabmd.conv = mabmd;
}
## Plot with weights bridge sampling
BMDL = c(BMDL, macib[1]); BMD = c(BMD, macib[2]); BMDU = c(BMDU, macib[3]) # all on original scale
names(BMDL) <- c("E4_N","IE4_N","H4_N","LN4_N","G4_N","QE4_N","P4_N","L4_N","E4_LN","IE4_LN","H4_LN","LN4_LN","G4_LN","QE4_LN","P4_LN","L4_LN","MA")
model = c("E4_N","IE4_N","H4_N","LN4_N","G4_N","QE4_N","P4_N","L4_N","E4_LN","IE4_LN","H4_LN","LN4_LN","G4_LN","QE4_LN","P4_LN","L4_LN","MA")
model = as.factor(model)
weight = c(rep(0,16),1)
names(weight) = c("E4_N","IE4_N","H4_N","LN4_N","G4_N","QE4_N","P4_N","L4_N","E4_LN","IE4_LN","H4_LN","LN4_LN","G4_LN","QE4_LN","P4_LN","L4_LN","MA")
for(i in names(lpwb)){
weight[names(weight)==i] = lpwb[names(lpwb)==i]
}
## Covariances
covs = t(data.frame(
E4_N = E4covNI,
IE4_N = IE4covNI,
H4_N = H4covNI,
LN4_N = LN4covNI,
G4_N = G4covNI,
QE4_N = QE4covNI,
P4_N = P4covNI,
L4_N = L4covNI,
E4_LN = E4covLNI,
IE4_LN = IE4covLNI,
H4_LN = H4covLNI,
LN4_LN = LN4covLNI,
G4_LN = G4covLNI,
QE4_LN = QE4covLNI,
P4_LN = P4covLNI,
L4_LN = L4covLNI
))
colnames(covs) = c("b-d", "BMD-d")
corrs = t(data.frame(
E4_N = E4corrNI,
IE4_N = IE4corrNI,
H4_N = H4corrNI,
LN4_N = LN4corrNI,
G4_N = G4corrNI,
QE4_N = QE4corrNI,
P4_N = P4corrNI,
L4_N = L4corrNI,
E4_LN = E4corrLNI,
IE4_LN = IE4corrLNI,
H4_LN = H4corrLNI,
LN4_LN = LN4corrLNI,
G4_LN = G4corrLNI,
QE4_LN = QE4corrLNI,
P4_LN = P4corrLNI,
L4_LN = L4corrLNI
))
colnames(corrs) = c("b-d", "BMD-d")
modelnames <- c("E4_N","IE4_N","H4_N","LN4_N","G4_N","QE4_N","P4_N","L4_N","E4_LN","IE4_LN","H4_LN","LN4_LN","G4_LN","QE4_LN","P4_LN","L4_LN")
if(macib[2]/macib[1] > 20){
warning('BMD/BMDL is larger than 20 for bridge sampling')
}
if(macib[3]/macib[1] > 50){
warning('BMDU/BMDL is larger than 50 for bridge sampling')
}
if(macib[2] < (data.N$data$x[2]*data.N$data$maxD/10)){
warning('BMD is 10 times lower than the lowest non-zero dose for bridge sampling')
}
if(macilp[2]/macilp[1] > 20){
warning('BMD/BMDL is larger than 20 for hybrid Laplace')
}
if(macilp[3]/macilp[1] > 50){
warning('BMDU/BMDL is larger than 50 for hybrid Laplace')
}
if(macilp[2] < (data.N$data$x[2]*data.N$data$maxD/10)){
warning('BMD is 10 times lower than the lowest non-zero dose for hybrid Laplace')
}
### best fitting model vs saturated ANOVA model
best.fit = modelnames[which(weight[1:16] == max(weight[1:16]))][1]
bfTest <- modelTest(best.fit, data.N, data.LN, get(paste0('fitstan', best.fit)), type = 'MCMC',
seed, ndraws, nrchains, nriterations, warmup, delta, treedepth)
warning(bfTest$warn.bf)
ret_results <- list(E4_N=E4outNI,IE4_N=IE4outNI,H4_N=H4outNI,LN4_N=LN4outNI,
G4_N=G4outNI,QE4_N=QE4outNI,P4_N=P4outNI,L4_N=L4outNI,
E4_LN=E4outLNI,IE4_LN=IE4outLNI,H4_LN=H4outLNI,LN4_LN=LN4outLNI,
G4_LN=G4outLNI,QE4_LN=QE4outLNI,P4_LN=P4outLNI,L4_LN=L4outLNI,
covs = covs, corrs = corrs,
weights_bridge_sampling=w.bs,
weights_laplace=lpwlp,
MA_bridge_sampling=macib,
MA_laplace=macilp,
llN=llN, llLN=llLN,
convergence=converged, bs_weights_conv=w.bs.conv,
ls_weights_conv=lpwlp.conv,
MA_bs_conv=macib.conv,
MA_ls_conv=macilp.conv,
MA_post_bs = BMDq_bs,
MA_post_ls = BMDq_ls,
MA_post_full_bs = mabmd1*data$maxD,
bkg_post_bs = mabkg1,
maxy_post_bs = mamaxy1,
MA_post_bs_conv = BMDq_bs_conv,
MA_post_ls_conv = BMDq_ls_conv,
MA_dr_bs = dr.MA.bs,
MA_dr_ls = dr.MA.ls,
MA_dr_bs_conv = dr.MA.bs.conv,
MA_dr_ls_conv = dr.MA.ls.conv,
parsN = list(parsE4N, parsIE4N, parsH4N, parsLN4N, parsG4N,
parsQE4N, parsP4N, parsL4N),
parsLN = list(parsE4LN, parsIE4LN, parsH4LN, parsLN4LN, parsG4LN,
parsQE4LN, parsP4LN, parsL4LN),
BMDMixture = (mabmd)*data$maxD,
BMDMixture.conv = (mabmd.conv)*data$maxD,
BMDMixtureBS = (mabmd1)*data$maxD,
BMDMixture.convBS = mabmd.conv1*data$maxD,
divergences = divergences,
dataN = data.frame(
dose = c(data.N$data$x),
sd = sqrt(data.N$data$s2),
m = data.N$data$m),
dataLN = data.frame(
dose = c(data.LN$data$x),
sd = sqrt(data.LN$data$s2),
m = data.LN$data$m.org),
max.dose = data.N$data$maxD,
q = data.N$data$q,
# increasing = T,
models_included_bridge = modelnames[p.weights > 0],
models_included_laplace = modelnames[lpwlp > 0],
bf = bfTest$bayesFactor, gof_check = bfTest$warn.bf,
means.SM = bfTest$means.SM, parBestFit = bfTest$par.best,
BIC.bestfit = bfTest$BIC.bestfit, BIC.SM = bfTest$BIC.SM,
shift = data.LN$data$shift,
w.msg = w.msg, p.msg = p.msg
)
mabmd1
mabkg1
mabkg1=(c( # normal
if("E4_N" %in% names(count)) sample(as.matrix(fitstanE4_N)[,"mu_0"],count[names(count)=="E4_N"],replace=T),
if("IE4_N" %in% names(count)) sample(as.matrix(fitstanIE4_N)[,"mu_0"],count[names(count)=="IE4_N"],replace=T),
if("H4_N" %in% names(count)) sample(as.matrix(fitstanH4_N)[,"mu_0"],count[names(count)=="H4_N"],replace=T),
if("LN4_N" %in% names(count)) sample(as.matrix(fitstanLN4_N)[,"mu_0"],count[names(count)=="LN4_N"],replace=T),
if("G4_N" %in% names(count)) sample(as.matrix(fitstanG4_N)[,"mu_0"],count[names(count)=="G4_N"],replace=T),
if("QE4_N" %in% names(count)) sample(as.matrix(fitstanQE4_N)[,"mu_0"],count[names(count)=="QE4_N"],replace=T),
if("P4_N" %in% names(count)) sample(as.matrix(fitstanP4_N)[,"mu_0"],count[names(count)=="P4_N"],replace=T),
if("L4_N" %in% names(count)) sample(as.matrix(fitstanL4_N)[,"mu_0"],count[names(count)=="L4_N"],replace=T),
# lognormal
if("E4_LN" %in% names(count)) sample(as.matrix(fitstanE4_LN)[,"mu_0"],count[names(count)=="E4_LN"],replace=T),
if("IE4_LN" %in% names(count)) sample(as.matrix(fitstanIE4_LN)[,"mu_0"],count[names(count)=="IE4_LN"],replace=T),
if("H4_LN" %in% names(count)) sample(as.matrix(fitstanH4_LN)[,"mu_0"],count[names(count)=="H4_LN"],replace=T),
if("LN4_LN" %in% names(count)) sample(as.matrix(fitstanLN4_LN)[,"mu_0"],count[names(count)=="LN4_LN"],replace=T),
if("G4_LN" %in% names(count)) sample(as.matrix(fitstanG4_LN)[,"mu_0"],count[names(count)=="G4_LN"],replace=T),
if("QE4_LN" %in% names(count)) sample(as.matrix(fitstanQE4_LN)[,"mu_0"],count[names(count)=="QE4_LN"],replace=T),
if("P4_LN" %in% names(count)) sample(as.matrix(fitstanP4_LN)[,"mu_0"],count[names(count)=="P4_LN"],replace=T),
if("L4_LN" %in% names(count)) sample(as.matrix(fitstanL4_LN)[,"mu_0"],count[names(count)=="L4_LN"],replace=T)
))
mamaxy1=(c( # normal
if("E4_N" %in% names(count)) sample(as.matrix(fitstanE4_N)[,"mu_inf"],count[names(count)=="E4_N"],replace=T),
if("IE4_N" %in% names(count)) sample(as.matrix(fitstanIE4_N)[,"mu_inf"],count[names(count)=="IE4_N"],replace=T),
if("H4_N" %in% names(count)) sample(as.matrix(fitstanH4_N)[,"mu_inf"],count[names(count)=="H4_N"],replace=T),
if("LN4_N" %in% names(count)) sample(as.matrix(fitstanLN4_N)[,"mu_inf"],count[names(count)=="LN4_N"],replace=T),
if("G4_N" %in% names(count)) sample(as.matrix(fitstanG4_N)[,"mu_inf"],count[names(count)=="G4_N"],replace=T),
if("QE4_N" %in% names(count)) sample(as.matrix(fitstanQE4_N)[,"mu_inf"],count[names(count)=="QE4_N"],replace=T),
if("P4_N" %in% names(count)) sample(as.matrix(fitstanP4_N)[,"mu_inf"],count[names(count)=="P4_N"],replace=T),
if("L4_N" %in% names(count)) sample(as.matrix(fitstanL4_N)[,"mu_inf"],count[names(count)=="L4_N"],replace=T),
# lognormal
if("E4_LN" %in% names(count)) sample(as.matrix(fitstanE4_LN)[,"mu_inf"],count[names(count)=="E4_LN"],replace=T),
if("IE4_LN" %in% names(count)) sample(as.matrix(fitstanIE4_LN)[,"mu_inf"],count[names(count)=="IE4_LN"],replace=T),
if("H4_LN" %in% names(count)) sample(as.matrix(fitstanH4_LN)[,"mu_inf"],count[names(count)=="H4_LN"],replace=T),
if("LN4_LN" %in% names(count)) sample(as.matrix(fitstanLN4_LN)[,"mu_inf"],count[names(count)=="LN4_LN"],replace=T),
if("G4_LN" %in% names(count)) sample(as.matrix(fitstanG4_LN)[,"mu_inf"],count[names(count)=="G4_LN"],replace=T),
if("QE4_LN" %in% names(count)) sample(as.matrix(fitstanQE4_LN)[,"mu_inf"],count[names(count)=="QE4_LN"],replace=T),
if("P4_LN" %in% names(count)) sample(as.matrix(fitstanP4_LN)[,"mu_inf"],count[names(count)=="P4_LN"],replace=T),
if("L4_LN" %in% names(count)) sample(as.matrix(fitstanL4_LN)[,"mu_inf"],count[names(count)=="L4_LN"],replace=T)
))
ret_results <- list(E4_N=E4outNI,IE4_N=IE4outNI,H4_N=H4outNI,LN4_N=LN4outNI,
G4_N=G4outNI,QE4_N=QE4outNI,P4_N=P4outNI,L4_N=L4outNI,
E4_LN=E4outLNI,IE4_LN=IE4outLNI,H4_LN=H4outLNI,LN4_LN=LN4outLNI,
G4_LN=G4outLNI,QE4_LN=QE4outLNI,P4_LN=P4outLNI,L4_LN=L4outLNI,
covs = covs, corrs = corrs,
weights_bridge_sampling=w.bs,
weights_laplace=lpwlp,
MA_bridge_sampling=macib,
MA_laplace=macilp,
llN=llN, llLN=llLN,
convergence=converged, bs_weights_conv=w.bs.conv,
ls_weights_conv=lpwlp.conv,
MA_bs_conv=macib.conv,
MA_ls_conv=macilp.conv,
MA_post_bs = BMDq_bs,
MA_post_ls = BMDq_ls,
MA_post_full_bs = mabmd1*data$maxD,
bkg_post_bs = mabkg1,
maxy_post_bs = mamaxy1,
MA_post_bs_conv = BMDq_bs_conv,
MA_post_ls_conv = BMDq_ls_conv,
MA_dr_bs = dr.MA.bs,
MA_dr_ls = dr.MA.ls,
MA_dr_bs_conv = dr.MA.bs.conv,
MA_dr_ls_conv = dr.MA.ls.conv,
parsN = list(parsE4N, parsIE4N, parsH4N, parsLN4N, parsG4N,
parsQE4N, parsP4N, parsL4N),
parsLN = list(parsE4LN, parsIE4LN, parsH4LN, parsLN4LN, parsG4LN,
parsQE4LN, parsP4LN, parsL4LN),
BMDMixture = (mabmd)*data$maxD,
BMDMixture.conv = (mabmd.conv)*data$maxD,
BMDMixtureBS = (mabmd1)*data$maxD,
BMDMixture.convBS = mabmd.conv1*data$maxD,
divergences = divergences,
dataN = data.frame(
dose = c(data.N$data$x),
sd = sqrt(data.N$data$s2),
m = data.N$data$m),
dataLN = data.frame(
dose = c(data.LN$data$x),
sd = sqrt(data.LN$data$s2),
m = data.LN$data$m.org),
max.dose = data.N$data$maxD,
q = data.N$data$q,
# increasing = T,
models_included_bridge = modelnames[p.weights > 0],
models_included_laplace = modelnames[lpwlp > 0],
bf = bfTest$bayesFactor, gof_check = bfTest$warn.bf,
means.SM = bfTest$means.SM, parBestFit = bfTest$par.best,
BIC.bestfit = bfTest$BIC.bestfit, BIC.SM = bfTest$BIC.SM,
shift = data.LN$data$shift,
w.msg = w.msg, p.msg = p.msg
)
attr(ret_results, "class") <- c("BMADR", "BS")
SBMD = sampling_MA(data_N, data_LN,
prior.weights,
ndraws=ndr, nrchains=nrch,
nriterations=nriter, warmup=wu, delta=dl,
treedepth=trd, seed=sd, pvec=pvec)
warnings()
# MA estimates
SBMD$MA_bridge_sampling
SBMD$MA_laplace
# convergence & divergence
SBMD$convergence
SBMD$divergences*100 # percentage of iterations that were divergent
# model-specific fit
SBMD$E4_N
# test whether best-fitting model fits wel (BF < 10 means equally well as saturated model; BF > 10 means best fit is better than saturated model)
SBMD$bf
# output as dataframe/list
BMDWeights(SBMD, 'continuous')
summary.BMADR(SBMD, 'continuous')
# plot output
pSBMD = plot.BMADR(SBMD, weight_type = "BS", type = 'increasing', include_data = T, all = F, title = '', conv = F)
pSBMD$BMDs
pSBMD$weights
pSBMD$model_fit_N
pSBMD$model_fit_LN
pSBMD$model_fit
pSBMD$MA_fit
library(dplyr)
library(BMABMDR)
library(gamlss)
generateData<-function(a,b,c,d,sigma,q,dose,seed){
### Mathematical equation defining the relationship ###
f.exp1<-function(a,CED,c,d,CES,x){
b <- - log((CES+1-c)/(1-c))/(CED^d)
f <- a * (c - (c - 1) * exp( - b * x^d))
return(f)
}
### BMD associated to the parameters used ###
BMDT <- (1/b*log((c-1)/(c-(1+q))))^(1/d)
BMDT
### Study design, doses used to generate the dataset ###
doseG<-rep(dose,each=20)
### Generating one simulated data ###
set.seed(seed)
logyG<-rnorm(length(doseG),
mean=log(f.exp1(a=a,CED=BMDT,c=c,d=d,CES=q,x=doseG)),   # note the log
sd=rep(sigma,length(doseG)))
### Final dataset with individual observations ###
data.gen <- data.frame(dose=doseG, y=exp(logyG))
data.sum<-data.gen %>% group_by(dose) %>% summarise(meanY=round(mean(y),1),
sdY=round(sd(y),3),
N=n())
return(data.sum)
}
a=7.5;b=6;c=2;d=1.2;sigma=0.05;q=0.05
i=3
data.sum<-generateData(a,b,c,d,sigma,q,dose=c(0,0.5,5,50),seed=1000*i)
data.sum
summ.data = data.frame(x = data.sum$dose, y = data.sum$meanY, s = data.sum$sdY, n = data.sum$N)
# sampling specification
ndr=30000
nrch=3;nriter=3000;wu=1000;dl=0.8;trd=10;sd=123
# prior model weights: example including only Normal distribution
prior.weights = c(rep(1,8), rep(1,8))
# bmr
q = 0.05
pvec = c(0.05,0.5,0.95)
# uninformative
data_N = PREP_DATA_N(summ.data,
sumstats = T,
q = q, extended = T)#, prior.BMD = c(0,0.2,0.5), shape.BMD = 0.0001)
data_LN = PREP_DATA_LN(summ.data,
sumstats = T,
q = q, extended = T)#, prior.BMD = c(0,0.2,0.5), shape.BMD = 0.0001)
SBMD = sampling_MA(data_N, data_LN,
prior.weights,
ndraws=ndr, nrchains=nrch,
nriterations=nriter, warmup=wu, delta=dl,
treedepth=trd, seed=sd, pvec=pvec)
warnings()
# MA estimates
SBMD$MA_bridge_sampling
SBMD$MA_laplace
